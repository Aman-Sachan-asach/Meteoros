// Ray March Reference: https://www.shadertoy.com/view/4sjfzw

#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE) in;
layout (set = 0, binding = 0, rgba8) uniform writeonly image2D resultImage;

layout (set = 0, binding = 1) uniform sampler3D cloudBaseShapeSampler;
layout (set = 0, binding = 2) uniform sampler3D cloudDetailsHighFreqSampler; // Dont use alpha channel
layout (set = 0, binding = 3) uniform sampler2D curlNoiseSampler; // Don't use alpha channel

layout (set = 0, binding = 4) uniform TimeUBO
{
    vec2 time; //stores delat time and total time
};

layout (set = 1, binding = 0) uniform CameraUBO
{
	mat4 view;
	mat4 proj;
	vec4 eye;
	vec2 tanFovBy2;
} camera;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Intersection {
    vec3 normal;
    vec3 point;
    bool valid;
    float t;
};

//Global Defines
#define earthRadius 6371000.0 // earth's actual radius in km = 6371
#define atmosphereRadiusInner earthRadius + 7500.0 //15000 meters above
#define atmosphereRadiusOuter earthRadius + 20000.0 //35000 meters above

#define inStratusMinMax vec2(0.0, 0.3)
#define inCumulusMinMax vec2(0.01, 0.45)
#define inCumulonimbusMinMax vec2(0.0, 0.95)

#define LightVec normalize(vec3(1.0,1.0,1.0));

#define PI 3.14159265
#define InvPI 0.31830988618
#define THREE_OVER_SIXTEEN_PI 0.05968310365946075
#define ONE_OVER_FOUR_PI 0.07957747154594767

#define E 2.718281828459
#define EPSILON 0.0001

#define NUM_FBM_OCTAVES 7

//Global Defines for Debug Views
#define LIGTHING false
#define CLOUDS_ALL_NOISES false
#define DENSITY_SLICES false
#define HEIGHT_GRADIENT false
#define TEXTURE_CURL_NOISE false
#define TEXTURE_HIGH_FREQ false
#define TEXTURE_LOW_FREQ false

float bias(float b, float t)
{
	return pow(t, log(b)/log(0.5f));
}

float gain(float g, float t)
{
	if(t<0.5) {
		return bias(1.0-g, 2.0*t)/2.0;
	}
	else {
		return 1.0 - bias(1.0-g, 2.0 - 2.0*t) / 2.0;
	}
}

// Maps values from one range to another
float remap(float value, float original_min, float original_max, float new_min, float new_max)
{
	return new_min + ( ((value-original_min) / (original_max - original_min)) * (new_max - new_min) );
}

//--------------------------------------------------------
//--------------------------------------------------------
//--------------------------------------------------------
// Procedural noise function for Fractal Brownian Motion taken from here: https://thebookofshaders.com/13/ and 
// Joe Klinger --> https://github.com/klingerj & https://www.shadertoy.com/user/jgkling
float noise(in vec2 p) { 
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);
}

float interpolateNoise(in vec2 p) {
    vec2 p_floor = floor(p);
    vec2 p_fract = p - p_floor;

    // Sample the noise function at grid intervals
    vec2 offset = vec2(0.0, 1.0);
    float noise00 = noise(p_floor);
    float noise01 = noise(p_floor + offset);
    float noise10 = noise(p_floor + offset.yx);
    float noise11 = noise(p_floor + offset.yy);

    // Bilinearly interpolate
    float noise_x1 = mix(noise00, noise10, p_fract.x);
    float noise_x2 = mix(noise01, noise11, p_fract.x);

    return mix(noise_x1, noise_x2, p_fract.y);
}

float FBM(in vec2 p) {
    float amplitude = 0.75;
    float frequency = 1.0;
    const float persistence = 0.5;
    float maxVal = 0.0;
    float accumNoise = 0.0;

    for(int i = 0; i < NUM_FBM_OCTAVES; ++i) {
        accumNoise += interpolateNoise(p * frequency) * amplitude;
        maxVal += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }

    float noiseVal = accumNoise / maxVal;
    noiseVal *= step(0.5, noiseVal);
    return max(0.0, remap(noiseVal, 0.5, 1.0, 0.0, 0.9));
}
//--------------------------------------------------------
//--------------------------------------------------------
//--------------------------------------------------------

//Compute Ray for ray marching based on screenspace point
Ray castRay( vec2 screenPoint, vec3 eye )
{
	Ray r;

    // Extract camera information from uniform
    vec3 camRight = normalize(vec3(camera.view[0][0], 
				    				camera.view[1][0], 
				    				camera.view[2][0] ));
    vec3 camUp =    normalize(vec3(camera.view[0][1], 
				    				camera.view[1][1], 
				    				camera.view[2][1] ));
    vec3 camLook =  -normalize(vec3(camera.view[0][2], 
				    				camera.view[1][2], 
				    				camera.view[2][2] ));

    // ScreenPoint is in NDC space

    //convert to camera space
    vec3 cam_x = screenPoint.x * camera.tanFovBy2.x * camRight;
    vec3 cam_y = screenPoint.y * camera.tanFovBy2.y * camUp;
    //convert to world space
    vec3 ref = eye+camLook;
    vec3 p = ref + cam_x + cam_y; //facing the screen

    r.origin = eye;
    r.direction = normalize(p - eye);

    return r;
}

// sphere Intersection
Intersection raySphereIntersection(in vec3 rO, in vec3 rD, in vec3 sphereCenter, in float sphereRadius)
{
    Intersection isect;
    isect.valid = false;
    isect.point = vec3(0.0);
    isect.normal = vec3(0.0, 1.0, 0.0);

    // Transform Ray such that the spheres move down, such that the camera is close to the sky dome
    // Only change sphere origin because you can't translate a direction
    rO -= sphereCenter;
    rO /= sphereRadius;

    float A = dot(rD, rD);
    float B = 2.0*dot(rD, rO);
    float C = dot(rO, rO) - 0.25; //uniform sphere
    float discriminant = B*B - 4.0*A*C;

    //If the discriminant is negative, then there is no real root
    if(discriminant < 0.0)
    {
        return isect;
    }

    float t = (-B - sqrt(discriminant))/(2.0*A);
    
    if(t < 0.0) 
    {
        t = (-B + sqrt(discriminant))/(2.0*A);
    }

    if(t >= 0.0)
    {
        vec3 p = vec3(rO + t*rD);
        isect.valid = true;
        isect.normal = normalize(p);

        p *= sphereRadius;
        p += sphereCenter;

        isect.point = p;
        isect.t = length(p-rO);
    }

    return isect;
}

float getHeightFractionForPoint(vec3 inPos, vec2 inCloudMinMax)
{
	float height_fraction = (inPos.z - inCloudMinMax.x) / (inCloudMinMax.y - inCloudMinMax.x);
	return clamp(height_fraction, 0.0, 1.0);
}

float getDensityHeightGradientForPoint(vec3 point, vec3 weather_data)
{
	//Refer: 2017 pdf of slides 29/108
	//CloudTypes --> stratus = 1; stratocumulus = 2; cumulus = 3;
	float stratus = remap(point.y, 0, 0.1, 0.0, 1.0) * remap(point.y, 0.2, 0.3, 1.0, 0.0);
	float cumulus = remap(point.y, 0.01, 0.3, 0.0, 1.0) * remap(point.y, 0.3, 0.45, 1.0, 0.0);
	float cumulonimbus = remap(point.y, 0.0, 0.25, 0.0, 1.0) * remap(point.y, 0.6, 0.95, 1.0, 0.0);

	float a = clamp(stratus, 0.0, 1.0);
	float b = clamp(cumulus, 0.0, 1.0);
	float c = clamp(cumulonimbus, 0.0, 1.0);

	//Make weighting based on the cloud type in the weather map
	float weight_a;
	float weight_b;
	float weight_c;

	if(weather_data.b == 0) {
		weight_a = 0.6;
		weight_b = 0.2;
		weight_c = 0.2;
	}
	else if(weather_data.b == 1) {
		weight_a = 0.2;
		weight_b = 0.6;
		weight_c = 0.2;
	}
	else if(weather_data.b == 0.5) {
		weight_a = 0.2;
		weight_b = 0.2;
		weight_c = 0.6;
	}
	
	 //Return a blended and weighted value
	return weight_a*a + weight_b*b + weight_c*c;
}

float sampleCloudDensity(vec3 point, vec3 weather_data)
{
	//Read in the low-frequency Perlin-Worley noises and Worley noises
	vec4 lowFrequencyNoises = texture(cloudBaseShapeSampler, point);

	//Build an FBM out of the low-frequency Worley Noises that are used to add detail to the Low-frequency Perlin Worley noise
	float lowFrequencyFBM = (lowFrequencyNoises.g * 0.625) + 
							(lowFrequencyNoises.b * 0.25)  + 
							(lowFrequencyNoises.a * 0.125);

	//Define the base cloud shape by dilating it with the low-frequency FBM
	float baseCloud = remap( lowFrequencyNoises.r, -(1.0 - lowFrequencyFBM), 1.0, 0.0, 1.0 );

	//Get the density-height gradient
	float densityHeightGradient = getDensityHeightGradientForPoint(point, weather_data);

	//Apply Height function to the base cloud shape
	baseCloud *= densityHeightGradient;

	// Cloud coverage is stored in weather dataâ€™s red channel .
	float cloud_coverage = 0.5;//TODO: Change to weather_data.r;

	// Use remap to apply the cloud coverage attribute.
	float base_cloud_with_coverage = remap ( baseCloud, cloud_coverage , 1.0 , 0.0 , 1.0);

	// To ensure that the density increases with coverage in an aesthetically pleasing manner
	// Multiply the result by the cloud coverage attribute so that smaller clouds are lighter 
	// and more aesthetically pleasing
	base_cloud_with_coverage *= cloud_coverage ;

	// Find inCloudMinMax
	vec2 inCloudMinMax;
	if(weather_data.b == 0) {
		inCloudMinMax = inStratusMinMax;
	}
	else if(weather_data.b == 1) {
		inCloudMinMax = inCumulusMinMax;
	}
	else if(weather_data.b == 0.5) {
		inCloudMinMax = inCumulonimbusMinMax;
	}

	float height_fraction = getHeightFractionForPoint(point, inCloudMinMax);

	// Add turbulence to the bottome of the clouds
	vec4 curlNoise = texture(curlNoiseSampler, point.xy);
	point.xy += curlNoise.xy * (1.0-height_fraction);

	// Sample High Frequency Noises
	vec4 highFrequencyNoise = texture(cloudDetailsHighFreqSampler, point);

	// Build High Frequency FBM
	float high_freq_FBM = (highFrequencyNoise.r * 0.625) + 
						  (highFrequencyNoise.g * 0.25)  +
						  (highFrequencyNoise.b * 0.125); 

	float high_freq_modifier = mix(high_freq_FBM, 1.0 - high_freq_FBM, clamp(height_fraction * 10.0, 0.0, 1.0));

	//Erode the base shape of the cloud with the distorted high frequency worley noises
	float final_cloud = remap(base_cloud_with_coverage, high_freq_modifier*0.2, 1.0, 0.0, 1.0);

	return final_cloud;
}

void rayMarch(Ray ray, vec3 weather_data, vec3 startPos, vec3 endPos, 
			float start_t, float end_t, inout float accumDensity, inout float transmittance)
{
	float maxSteps = floor(mix(52, 84, 1.0 - ray.direction.y));
	float stepSize = (end_t - start_t)/maxSteps;

    vec3 pos;
    float density;

	for (float t = start_t; t < end_t; t += stepSize)
	{
		pos = ray.origin + t * ray.direction;

		// Adjust the position to represent spherical-ness of world
		// vec3 correctedPos = normalize(pos - vec3(0, 0, -earthRadius)) * atmosphereRadiusInner;
		vec3 samplePoint = vec3(pos.x, pos.y, abs(pos.z));//normalize(pos - vec3(0, 0, -earthRadius)) * atmosphereRadiusInner;//pos;//(pos-startPos);///endPos;
		samplePoint /= 30000.0;//fixed value found by tweaking don't change or else you will see the tiled texture and notice the repition

		density = sampleCloudDensity(samplePoint, weather_data);

		if(density > 0.0) // Useful to prevent lighting calculations for zero density points
		{
			accumDensity += density*(1/8.0);

			// Do Lighting calculations with cone sampling
			float densityAlongLight = 0.0;
			
			
			//transmittance = mix(transmittance, max(exp(-densityAlongLight), 0.7 * exp(-0.25 * densityAlongLight)), (1.0 - accumDensity));
		}
		
		if(accumDensity >=1.0) {
			accumDensity = 1.0;
			break;
		}
	}
}

void main() 
{
    ivec2 dim = imageSize(resultImage);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

	vec3 weather_data = vec3(1,1,1); //Use Actual Texture
	vec3 backgroundCol = vec3(0,0,1); //Change to be based on the atmosphere background color because of the preetham model

	// Cast a ray
	uv.y = 1.0 - uv.y; //cause vulkan inverts y compared to openGL
	vec2 screenPoint = uv * 2.0 - 1.0; // Compute screen space point from UVs //x and y move from -1 to 1
	vec3 eyePos = -camera.eye.xyz;

	Ray ray = castRay(screenPoint, eyePos);

	if (dot( vec3(0,1,0), ray.direction ) < 0.0 )
	{
		//kill threads because we shouldnt see stuff below the horizon

		// Change the Color From blue to something based on the atmosphere color

		imageStore( resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(backgroundCol,1.0) );
		return;
	}

	// Find the start and en points of the ray march
	vec3 earthCenter = eyePos;
	earthCenter.y = -earthRadius * 0.5; //move earth below camera
	Intersection atmospherInnerIsect = raySphereIntersection(ray.origin, ray.direction, earthCenter, atmosphereRadiusInner);
	Intersection atmospherOuterIsect = raySphereIntersection(ray.origin, ray.direction, earthCenter, atmosphereRadiusOuter);

	// Ray March
	float transmittance = 1.0;
    float accumDensity = 0.0;
	rayMarch(ray, weather_data, atmospherInnerIsect.point, atmospherOuterIsect.point, 
			atmospherInnerIsect.t, atmospherOuterIsect.t, accumDensity, transmittance);

	// opacity fades to prevent hard cutoff at horizon blend in with 
    accumDensity *= smoothstep(0, 1, min(1, remap(ray.direction.y, 0, 0.05, 0, 1)));

    vec4 finalColor = vec4(mix(backgroundCol, vec3(clamp(transmittance, 0.0, 1.0)), accumDensity), 1.0);

#ifdef HEIGHT_GRADIENT
	float densityHeightGradient = getDensityHeightGradientForPoint( vec3(uv, 1.0), weather_data );
	finalColor = vec4(densityHeightGradient);
#endif
#ifdef TEXTURE_LOW_FREQ
	vec4 lowFrequencyNoises = texture( cloudBaseShapeSampler, vec3(uv, sin(time.y)) );
	finalColor = vec4(lowFrequencyNoises);
#endif
#ifdef TEXTURE_HIGH_FREQ
	vec4 highFrequencyNoises = texture( cloudDetailsHighFreqSampler, vec3(uv, sin(time.y)) );
	finalColor = vec4(highFrequencyNoises);
#endif
#ifdef TEXTURE_CURL_NOISE
	vec4 curlNoise = texture( curlNoiseSampler, uv );
	finalColor = vec4(curlNoise);
#endif
#ifdef DENSITY_SLICES
	float density = sampleCloudDensity( vec3(uv, sin(time.y)), weather_data );
	finalColor = normalize( vec4(vec3(density), 1.0) );
#endif
#ifdef CLOUDS_ALL_NOISES
	finalColor = vec4( vec3(accumDensity), 1.0 );
#endif
#ifdef LIGTHING
#endif
	
	//Pass the color off to the cloud pipeline's frag shader
    imageStore( resultImage, ivec2(gl_GlobalInvocationID.xy), finalColor );
}